{"version":3,"file":"utils-DFvkL3Ii.mjs","names":["iterable: Iterable<Promise<T>>","message: string","source: Record<any, any> | undefined | null","target: Record<any, any> | undefined | null"],"sources":["../../src/utils/allSettled.ts","../../src/utils/logErrorInDevMode.ts","../../src/utils/fastDeepMerge.ts"],"sourcesContent":["/**\n * A ES6 compatible utility that implements `Promise.allSettled`\n * @internal\n */\nexport function allSettled<T>(\n  iterable: Iterable<Promise<T>>,\n): Promise<({ status: 'fulfilled'; value: T } | { status: 'rejected'; reason: any })[]> {\n  const promises = Array.from(iterable).map(p =>\n    p.then(\n      value => ({ status: 'fulfilled', value }) as const,\n      reason => ({ status: 'rejected', reason }) as const,\n    ),\n  );\n  return Promise.all(promises);\n}\n","import { isDevelopmentEnvironment } from './runtimeEnvironment';\n\nexport const logErrorInDevMode = (message: string) => {\n  if (isDevelopmentEnvironment()) {\n    console.error(`Clerk: ${message}`);\n  }\n};\n","/**\n * Merges 2 objects without creating new object references\n * The merged props will appear on the `target` object\n * If `target` already has a value for a given key it will not be overwritten\n */\nexport const fastDeepMergeAndReplace = (\n  source: Record<any, any> | undefined | null,\n  target: Record<any, any> | undefined | null,\n) => {\n  if (!source || !target) {\n    return;\n  }\n\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key) && source[key] !== null && typeof source[key] === `object`) {\n      if (target[key] === undefined) {\n        target[key] = new (Object.getPrototypeOf(source[key]).constructor)();\n      }\n      fastDeepMergeAndReplace(source[key], target[key]);\n    } else if (Object.prototype.hasOwnProperty.call(source, key)) {\n      target[key] = source[key];\n    }\n  }\n};\n\nexport const fastDeepMergeAndKeep = (\n  source: Record<any, any> | undefined | null,\n  target: Record<any, any> | undefined | null,\n) => {\n  if (!source || !target) {\n    return;\n  }\n\n  for (const key in source) {\n    if (Object.prototype.hasOwnProperty.call(source, key) && source[key] !== null && typeof source[key] === `object`) {\n      if (target[key] === undefined) {\n        target[key] = new (Object.getPrototypeOf(source[key]).constructor)();\n      }\n      fastDeepMergeAndKeep(source[key], target[key]);\n    } else if (Object.prototype.hasOwnProperty.call(source, key) && target[key] === undefined) {\n      target[key] = source[key];\n    }\n  }\n};\n"],"mappings":";;;;;;;AAIA,SAAgB,WACdA,UACsF;CACtF,MAAM,WAAW,MAAM,KAAK,SAAS,CAAC,IAAI,OACxC,EAAE,KACA,YAAU;EAAE,QAAQ;EAAa;CAAO,IACxC,aAAW;EAAE,QAAQ;EAAY;CAAQ,GAC1C,CACF;AACD,QAAO,QAAQ,IAAI,SAAS;AAC7B;;;;ACZD,MAAa,oBAAoB,CAACC,YAAoB;AACpD,KAAI,0BAA0B,CAC5B,SAAQ,OAAO,SAAS,QAAQ,EAAE;AAErC;;;;;;;;;ACDD,MAAa,0BAA0B,CACrCC,QACAC,WACG;AACH,MAAK,WAAW,OACd;AAGF,MAAK,MAAM,OAAO,OAChB,KAAI,OAAO,UAAU,eAAe,KAAK,QAAQ,IAAI,IAAI,OAAO,SAAS,eAAe,OAAO,UAAU,SAAS;AAChH,MAAI,OAAO,gBACT,QAAO,OAAO,KAAK,OAAO,eAAe,OAAO,KAAK,EAAC;AAExD,0BAAwB,OAAO,MAAM,OAAO,KAAK;CAClD,WAAU,OAAO,UAAU,eAAe,KAAK,QAAQ,IAAI,CAC1D,QAAO,OAAO,OAAO;AAG1B;AAED,MAAa,uBAAuB,CAClCD,QACAC,WACG;AACH,MAAK,WAAW,OACd;AAGF,MAAK,MAAM,OAAO,OAChB,KAAI,OAAO,UAAU,eAAe,KAAK,QAAQ,IAAI,IAAI,OAAO,SAAS,eAAe,OAAO,UAAU,SAAS;AAChH,MAAI,OAAO,gBACT,QAAO,OAAO,KAAK,OAAO,eAAe,OAAO,KAAK,EAAC;AAExD,uBAAqB,OAAO,MAAM,OAAO,KAAK;CAC/C,WAAU,OAAO,UAAU,eAAe,KAAK,QAAQ,IAAI,IAAI,OAAO,gBACrE,QAAO,OAAO,OAAO;AAG1B"}