{"version":3,"file":"telemetry-6CzUREWH.js","names":["cache: ThrottlerCache","#cache","payload: TelemetryEvent","#generateKey","#cacheTtl","event: TelemetryEvent","sanitizedEvent: Omit<TelemetryEvent, 'sk' | 'pk' | 'payload'> & TelemetryEvent['payload']","key: string","#getCache","value: TtlInMilliseconds","#storageKey","err: unknown","#maxSize","clerk: unknown","DEFAULT_CONFIG: Partial<TelemetryCollectorConfig>","options: TelemetryCollectorOptions","#config","#metadata","#eventThrottler","event: TelemetryEventRaw","#preparePayload","#logEvent","#shouldRecord","#buffer","#scheduleFlush","entry: TelemetryLogEntry","#shouldRecordLog","normalizedTimestamp: Date | null","timestampInput: unknown","#getSDKMetadata","logData: TelemetryLogData","#sanitizeContext","preparedPayload: TelemetryEvent","eventSamplingRate?: number","#shouldBeSampled","_entry: TelemetryLogEntry","#flush","#pendingFlush","event: TelemetryEvent['event']","payload: Record<string, any>","payload: TelemetryEvent['payload']","context: unknown","EVENT_SAMPLING_RATE","component: string","event: typeof EVENT_COMPONENT_MOUNTED | typeof EVENT_COMPONENT_OPENED","props?: Record<string, any>","additionalPayload?: TelemetryEventRaw['payload']","props: TelemetryEventRaw['payload']","EVENT_SAMPLING_RATE","method: string","payload?: Record<string, unknown>","EVENT_SAMPLING_RATE","payload: EventFrameworkMetadata","appearance?: Appearance","themeName: string | undefined","theme: BaseTheme"],"sources":["../../src/telemetry/throttler.ts","../../src/telemetry/collector.ts","../../src/telemetry/events/component-mounted.ts","../../src/telemetry/events/method-called.ts","../../src/telemetry/events/framework-metadata.ts","../../src/telemetry/events/theme-usage.ts"],"sourcesContent":["import type { TelemetryEvent } from '../types';\n\ntype TtlInMilliseconds = number;\n\nconst DEFAULT_CACHE_TTL_MS = 86400000; // 24 hours\n\n/**\n * Interface for cache storage used by the telemetry throttler.\n * Implementations can use localStorage, in-memory storage, or any other storage mechanism.\n */\nexport interface ThrottlerCache {\n  getItem(key: string): TtlInMilliseconds | undefined;\n  setItem(key: string, value: TtlInMilliseconds): void;\n  removeItem(key: string): void;\n}\n\n/**\n * Manages throttling for telemetry events using a configurable cache implementation\n * to mitigate event flooding in frequently executed code paths.\n */\nexport class TelemetryEventThrottler {\n  #cache: ThrottlerCache;\n  #cacheTtl = DEFAULT_CACHE_TTL_MS;\n\n  constructor(cache: ThrottlerCache) {\n    this.#cache = cache;\n  }\n\n  isEventThrottled(payload: TelemetryEvent): boolean {\n    const now = Date.now();\n    const key = this.#generateKey(payload);\n    const entry = this.#cache.getItem(key);\n\n    if (!entry) {\n      this.#cache.setItem(key, now);\n      return false;\n    }\n\n    const shouldInvalidate = now - entry > this.#cacheTtl;\n    if (shouldInvalidate) {\n      this.#cache.setItem(key, now);\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Generates a consistent unique key for telemetry events by sorting payload properties.\n   * This ensures that payloads with identical content in different orders produce the same key.\n   */\n  #generateKey(event: TelemetryEvent): string {\n    const { sk: _sk, pk: _pk, payload, ...rest } = event;\n\n    const sanitizedEvent: Omit<TelemetryEvent, 'sk' | 'pk' | 'payload'> & TelemetryEvent['payload'] = {\n      ...payload,\n      ...rest,\n    };\n\n    return JSON.stringify(\n      Object.keys({\n        ...payload,\n        ...rest,\n      })\n        .sort()\n        .map(key => sanitizedEvent[key]),\n    );\n  }\n}\n\n/**\n * LocalStorage-based cache implementation for browser environments.\n */\nexport class LocalStorageThrottlerCache implements ThrottlerCache {\n  #storageKey = 'clerk_telemetry_throttler';\n\n  getItem(key: string): TtlInMilliseconds | undefined {\n    return this.#getCache()[key];\n  }\n\n  setItem(key: string, value: TtlInMilliseconds): void {\n    try {\n      const cache = this.#getCache();\n      cache[key] = value;\n      localStorage.setItem(this.#storageKey, JSON.stringify(cache));\n    } catch (err: unknown) {\n      const isQuotaExceededError =\n        err instanceof DOMException &&\n        // Check error names for different browsers\n        (err.name === 'QuotaExceededError' || err.name === 'NS_ERROR_DOM_QUOTA_REACHED');\n\n      if (isQuotaExceededError && localStorage.length > 0) {\n        // Clear our cache if quota exceeded\n        localStorage.removeItem(this.#storageKey);\n      }\n    }\n  }\n\n  removeItem(key: string): void {\n    try {\n      const cache = this.#getCache();\n      delete cache[key];\n      localStorage.setItem(this.#storageKey, JSON.stringify(cache));\n    } catch {\n      // Silently fail if we can't remove\n    }\n  }\n\n  #getCache(): Record<string, TtlInMilliseconds> {\n    try {\n      const cacheString = localStorage.getItem(this.#storageKey);\n      if (!cacheString) {\n        return {};\n      }\n      return JSON.parse(cacheString);\n    } catch {\n      return {};\n    }\n  }\n\n  static isSupported(): boolean {\n    return typeof window !== 'undefined' && !!window.localStorage;\n  }\n}\n\n/**\n * In-memory cache implementation for non-browser environments (e.g., React Native).\n */\nexport class InMemoryThrottlerCache implements ThrottlerCache {\n  #cache: Map<string, TtlInMilliseconds> = new Map();\n  #maxSize = 10000; // Defensive limit to prevent memory issues\n\n  getItem(key: string): TtlInMilliseconds | undefined {\n    // Defensive: clear cache if it gets too large\n    if (this.#cache.size > this.#maxSize) {\n      this.#cache.clear();\n      return undefined;\n    }\n\n    return this.#cache.get(key);\n  }\n\n  setItem(key: string, value: TtlInMilliseconds): void {\n    this.#cache.set(key, value);\n  }\n\n  removeItem(key: string): void {\n    this.#cache.delete(key);\n  }\n}\n","/**\n * The `TelemetryCollector` class handles collection of telemetry events from Clerk SDKs. Telemetry is opt-out and can be disabled by setting a CLERK_TELEMETRY_DISABLED environment variable.\n * The `ClerkProvider` also accepts a `telemetry` prop that will be passed to the collector during initialization:.\n *\n * ```jsx\n * <ClerkProvider telemetry={false}>\n *    ...\n * </ClerkProvider>\n * ```\n *\n * For more information, please see the telemetry documentation page: https://clerk.com/docs/telemetry.\n */\nimport { parsePublishableKey } from '../keys';\nimport type {\n  InstanceType,\n  SDKMetadata,\n  TelemetryCollector as TelemetryCollectorInterface,\n  TelemetryEvent,\n  TelemetryEventRaw,\n  TelemetryLogEntry,\n} from '../types';\nimport { isTruthy } from '../underscore';\nimport { InMemoryThrottlerCache, LocalStorageThrottlerCache, TelemetryEventThrottler } from './throttler';\nimport type { TelemetryCollectorOptions } from './types';\n\n/**\n * Local interface for window.Clerk to avoid global type pollution.\n * This is only used within this module and doesn't affect other packages.\n */\ninterface WindowWithClerk extends Window {\n  Clerk?: {\n    constructor?: {\n      sdkMetadata?: SDKMetadata;\n    };\n  };\n}\n\n/**\n * Type guard to check if window.Clerk exists and has the expected structure.\n */\nfunction isWindowClerkWithMetadata(clerk: unknown): clerk is { constructor: { sdkMetadata?: SDKMetadata } } {\n  return (\n    typeof clerk === 'object' && clerk !== null && 'constructor' in clerk && typeof clerk.constructor === 'function'\n  );\n}\n\ntype TelemetryCollectorConfig = Pick<\n  TelemetryCollectorOptions,\n  'samplingRate' | 'disabled' | 'debug' | 'maxBufferSize' | 'perEventSampling'\n> & {\n  endpoint: string;\n};\n\ntype TelemetryMetadata = Required<\n  Pick<TelemetryCollectorOptions, 'clerkVersion' | 'sdk' | 'sdkVersion' | 'publishableKey' | 'secretKey'>\n> & {\n  /**\n   * The instance type, derived from the provided publishableKey.\n   */\n  instanceType: InstanceType;\n};\n\n/**\n * Structure of log data sent to the telemetry endpoint.\n */\ntype TelemetryLogData = {\n  /** Service that generated the log. */\n  sdk: string;\n  /** The version of the SDK where the event originated from. */\n  sdkv: string;\n  /** The version of Clerk where the event originated from. */\n  cv: string;\n  /** Log level (info, warn, error, debug, etc.). */\n  lvl: TelemetryLogEntry['level'];\n  /** Log message. */\n  msg: string;\n  /** Instance ID - optional. */\n  iid?: string;\n  /** Timestamp when log was generated. */\n  ts: string;\n  /** Primary key. */\n  pk: string | null;\n  /** Additional payload for the log. */\n  payload: Record<string, unknown> | null;\n};\n\ntype TelemetryBufferItem = { kind: 'event'; value: TelemetryEvent } | { kind: 'log'; value: TelemetryLogData };\n\n// Accepted log levels for runtime validation\nconst VALID_LOG_LEVELS = new Set<string>(['error', 'warn', 'info', 'debug', 'trace']);\n\nconst DEFAULT_CONFIG: Partial<TelemetryCollectorConfig> = {\n  samplingRate: 1,\n  maxBufferSize: 5,\n  // Production endpoint: https://clerk-telemetry.com\n  // Staging endpoint: https://staging.clerk-telemetry.com\n  // Local: http://localhost:8787\n  endpoint: 'https://clerk-telemetry.com',\n};\n\nexport class TelemetryCollector implements TelemetryCollectorInterface {\n  #config: Required<TelemetryCollectorConfig>;\n  #eventThrottler: TelemetryEventThrottler;\n  #metadata: TelemetryMetadata = {} as TelemetryMetadata;\n  #buffer: TelemetryBufferItem[] = [];\n  #pendingFlush: number | ReturnType<typeof setTimeout> | null = null;\n\n  constructor(options: TelemetryCollectorOptions) {\n    this.#config = {\n      maxBufferSize: options.maxBufferSize ?? DEFAULT_CONFIG.maxBufferSize,\n      samplingRate: options.samplingRate ?? DEFAULT_CONFIG.samplingRate,\n      perEventSampling: options.perEventSampling ?? true,\n      disabled: options.disabled ?? false,\n      debug: options.debug ?? false,\n      endpoint: DEFAULT_CONFIG.endpoint,\n    } as Required<TelemetryCollectorConfig>;\n\n    if (!options.clerkVersion && typeof window === 'undefined') {\n      // N/A in a server environment\n      this.#metadata.clerkVersion = '';\n    } else {\n      this.#metadata.clerkVersion = options.clerkVersion ?? '';\n    }\n\n    // We will try to grab the SDK data lazily when an event is triggered, so it should always be defined once the event is sent.\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.#metadata.sdk = options.sdk!;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.#metadata.sdkVersion = options.sdkVersion!;\n\n    this.#metadata.publishableKey = options.publishableKey ?? '';\n\n    const parsedKey = parsePublishableKey(options.publishableKey);\n    if (parsedKey) {\n      this.#metadata.instanceType = parsedKey.instanceType;\n    }\n\n    if (options.secretKey) {\n      // Only send the first 16 characters of the secret key to to avoid sending the full key. We can still query against the partial key.\n      this.#metadata.secretKey = options.secretKey.substring(0, 16);\n    }\n\n    // Use LocalStorage cache in browsers where it's supported, otherwise fall back to in-memory cache\n    const cache = LocalStorageThrottlerCache.isSupported()\n      ? new LocalStorageThrottlerCache()\n      : new InMemoryThrottlerCache();\n    this.#eventThrottler = new TelemetryEventThrottler(cache);\n  }\n\n  get isEnabled(): boolean {\n    if (this.#metadata.instanceType !== 'development') {\n      return false;\n    }\n\n    // In browser or client environments, we most likely pass the disabled option to the collector, but in environments\n    // where environment variables are available we also check for `CLERK_TELEMETRY_DISABLED`.\n    if (\n      this.#config.disabled ||\n      (typeof process !== 'undefined' && process.env && isTruthy(process.env.CLERK_TELEMETRY_DISABLED))\n    ) {\n      return false;\n    }\n\n    // navigator.webdriver is a property generally set by headless browsers that are running in an automated testing environment.\n    // Data from these environments is not meaningful for us and has the potential to produce a large volume of events, so we disable\n    // collection in this case. (ref: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/webdriver)\n    if (typeof window !== 'undefined' && !!window?.navigator?.webdriver) {\n      return false;\n    }\n\n    return true;\n  }\n\n  get isDebug(): boolean {\n    return (\n      this.#config.debug ||\n      (typeof process !== 'undefined' && process.env && isTruthy(process.env.CLERK_TELEMETRY_DEBUG))\n    );\n  }\n\n  record(event: TelemetryEventRaw): void {\n    try {\n      const preparedPayload = this.#preparePayload(event.event, event.payload);\n\n      this.#logEvent(preparedPayload.event, preparedPayload);\n\n      if (!this.#shouldRecord(preparedPayload, event.eventSamplingRate)) {\n        return;\n      }\n\n      this.#buffer.push({ kind: 'event', value: preparedPayload });\n\n      this.#scheduleFlush();\n    } catch (error) {\n      console.error('[clerk/telemetry] Error recording telemetry event', error);\n    }\n  }\n\n  /**\n   * Records a telemetry log entry if logging is enabled and not in debug mode.\n   *\n   * @param entry - The telemetry log entry to record.\n   */\n  recordLog(entry: TelemetryLogEntry): void {\n    try {\n      if (!this.#shouldRecordLog(entry)) {\n        return;\n      }\n\n      const levelIsValid = typeof entry?.level === 'string' && VALID_LOG_LEVELS.has(entry.level);\n      const messageIsValid = typeof entry?.message === 'string' && entry.message.trim().length > 0;\n\n      let normalizedTimestamp: Date | null = null;\n      const timestampInput: unknown = (entry as unknown as { timestamp?: unknown })?.timestamp;\n      if (typeof timestampInput === 'number' || typeof timestampInput === 'string') {\n        const candidate = new Date(timestampInput);\n        if (!Number.isNaN(candidate.getTime())) {\n          normalizedTimestamp = candidate;\n        }\n      }\n\n      if (!levelIsValid || !messageIsValid || normalizedTimestamp === null) {\n        if (this.isDebug && typeof console !== 'undefined') {\n          console.warn('[clerk/telemetry] Dropping invalid telemetry log entry', {\n            levelIsValid,\n            messageIsValid,\n            timestampIsValid: normalizedTimestamp !== null,\n          });\n        }\n        return;\n      }\n\n      const sdkMetadata = this.#getSDKMetadata();\n\n      const logData: TelemetryLogData = {\n        sdk: sdkMetadata.name,\n        sdkv: sdkMetadata.version,\n        cv: this.#metadata.clerkVersion ?? '',\n        lvl: entry.level,\n        msg: entry.message,\n        ts: normalizedTimestamp.toISOString(),\n        pk: this.#metadata.publishableKey || null,\n        payload: this.#sanitizeContext(entry.context),\n      };\n\n      this.#buffer.push({ kind: 'log', value: logData });\n\n      this.#scheduleFlush();\n    } catch (error) {\n      console.error('[clerk/telemetry] Error recording telemetry log entry', error);\n    }\n  }\n\n  #shouldRecord(preparedPayload: TelemetryEvent, eventSamplingRate?: number) {\n    return this.isEnabled && !this.isDebug && this.#shouldBeSampled(preparedPayload, eventSamplingRate);\n  }\n\n  #shouldRecordLog(_entry: TelemetryLogEntry): boolean {\n    // Always allow logs from debug logger to be sent. Debug logger itself is already gated elsewhere.\n    return true;\n  }\n\n  #shouldBeSampled(preparedPayload: TelemetryEvent, eventSamplingRate?: number) {\n    const randomSeed = Math.random();\n\n    const toBeSampled =\n      randomSeed <= this.#config.samplingRate &&\n      (this.#config.perEventSampling === false ||\n        typeof eventSamplingRate === 'undefined' ||\n        randomSeed <= eventSamplingRate);\n\n    if (!toBeSampled) {\n      return false;\n    }\n\n    return !this.#eventThrottler.isEventThrottled(preparedPayload);\n  }\n\n  #scheduleFlush(): void {\n    // On the server, we want to flush immediately as we have less guarantees about the lifecycle of the process\n    if (typeof window === 'undefined') {\n      this.#flush();\n      return;\n    }\n    const isBufferFull = this.#buffer.length >= this.#config.maxBufferSize;\n    if (isBufferFull) {\n      // If the buffer is full, flush immediately to make sure we minimize the chance of event loss.\n      // Cancel any pending flushes as we're going to flush immediately\n      if (this.#pendingFlush) {\n        if (typeof cancelIdleCallback !== 'undefined') {\n          cancelIdleCallback(Number(this.#pendingFlush));\n        } else {\n          clearTimeout(Number(this.#pendingFlush));\n        }\n      }\n      this.#flush();\n      return;\n    }\n\n    // If we have a pending flush, do nothing\n    if (this.#pendingFlush) {\n      return;\n    }\n\n    if ('requestIdleCallback' in window) {\n      this.#pendingFlush = requestIdleCallback(() => {\n        this.#flush();\n        this.#pendingFlush = null;\n      });\n    } else {\n      // This is not an ideal solution, but it at least waits until the next tick\n      this.#pendingFlush = setTimeout(() => {\n        this.#flush();\n        this.#pendingFlush = null;\n      }, 0);\n    }\n  }\n\n  #flush(): void {\n    // Capture the current buffer and clear it immediately to avoid closure references\n    const itemsToSend = [...this.#buffer];\n    this.#buffer = [];\n\n    this.#pendingFlush = null;\n\n    if (itemsToSend.length === 0) {\n      return;\n    }\n\n    const eventsToSend = itemsToSend\n      .filter(item => item.kind === 'event')\n      .map(item => (item as { kind: 'event'; value: TelemetryEvent }).value);\n\n    const logsToSend = itemsToSend\n      .filter(item => item.kind === 'log')\n      .map(item => (item as { kind: 'log'; value: TelemetryLogData }).value);\n\n    if (eventsToSend.length > 0) {\n      const eventsUrl = new URL('/v1/event', this.#config.endpoint);\n      fetch(eventsUrl, {\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        keepalive: true,\n        method: 'POST',\n        // TODO: We send an array here with that idea that we can eventually send multiple events.\n        body: JSON.stringify({ events: eventsToSend }),\n      }).catch(() => void 0);\n    }\n\n    if (logsToSend.length > 0) {\n      const logsUrl = new URL('/v1/logs', this.#config.endpoint);\n      fetch(logsUrl, {\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        keepalive: true,\n        method: 'POST',\n        body: JSON.stringify({ logs: logsToSend }),\n      }).catch(() => void 0);\n    }\n  }\n\n  /**\n   * If running in debug mode, log the event and its payload to the console.\n   */\n  #logEvent(event: TelemetryEvent['event'], payload: Record<string, any>) {\n    if (!this.isDebug) {\n      return;\n    }\n\n    if (typeof console.groupCollapsed !== 'undefined') {\n      console.groupCollapsed('[clerk/telemetry]', event);\n      console.log(payload);\n      console.groupEnd();\n    } else {\n      console.log('[clerk/telemetry]', event, payload);\n    }\n  }\n\n  /**\n   * If in browser, attempt to lazily grab the SDK metadata from the Clerk singleton, otherwise fallback to the initially passed in values.\n   *\n   * This is necessary because the sdkMetadata can be set by the host SDK after the TelemetryCollector is instantiated.\n   */\n  #getSDKMetadata() {\n    const sdkMetadata = {\n      name: this.#metadata.sdk,\n      version: this.#metadata.sdkVersion,\n    };\n\n    if (typeof window !== 'undefined') {\n      const windowWithClerk = window as WindowWithClerk;\n\n      if (windowWithClerk.Clerk) {\n        const windowClerk = windowWithClerk.Clerk;\n\n        if (isWindowClerkWithMetadata(windowClerk) && windowClerk.constructor.sdkMetadata) {\n          const { name, version } = windowClerk.constructor.sdkMetadata;\n\n          if (name !== undefined) {\n            sdkMetadata.name = name;\n          }\n          if (version !== undefined) {\n            sdkMetadata.version = version;\n          }\n        }\n      }\n    }\n\n    return sdkMetadata;\n  }\n\n  /**\n   * Append relevant metadata from the Clerk singleton to the event payload.\n   */\n  #preparePayload(event: TelemetryEvent['event'], payload: TelemetryEvent['payload']): TelemetryEvent {\n    const sdkMetadata = this.#getSDKMetadata();\n\n    return {\n      event,\n      cv: this.#metadata.clerkVersion ?? '',\n      it: this.#metadata.instanceType ?? '',\n      sdk: sdkMetadata.name,\n      sdkv: sdkMetadata.version,\n      ...(this.#metadata.publishableKey ? { pk: this.#metadata.publishableKey } : {}),\n      ...(this.#metadata.secretKey ? { sk: this.#metadata.secretKey } : {}),\n      payload,\n    };\n  }\n\n  /**\n   * Best-effort sanitization of the context payload. Returns a plain object with JSON-serializable\n   * values or null when the input is missing or not serializable. Arrays are not accepted.\n   */\n  #sanitizeContext(context: unknown): Record<string, unknown> | null {\n    if (context === null || typeof context === 'undefined') {\n      return null;\n    }\n    if (typeof context !== 'object') {\n      return null;\n    }\n    try {\n      const cleaned = JSON.parse(JSON.stringify(context));\n      if (cleaned && typeof cleaned === 'object' && !Array.isArray(cleaned)) {\n        return cleaned as Record<string, unknown>;\n      }\n      return null;\n    } catch {\n      return null;\n    }\n  }\n}\n","import type { TelemetryEventRaw } from '../../types';\n\nconst EVENT_COMPONENT_MOUNTED = 'COMPONENT_MOUNTED';\nconst EVENT_COMPONENT_OPENED = 'COMPONENT_OPENED';\nconst EVENT_SAMPLING_RATE = 0.1;\n\n/** Increase sampling for high-signal auth components on mount. */\nconst AUTH_COMPONENTS = new Set<string>(['SignIn', 'SignUp']);\n\n/**\n * Returns the per-event sampling rate for component-mounted telemetry events.\n * Uses a higher rate for SignIn/SignUp to improve signal quality.\n *\n *  @internal\n */\nfunction getComponentMountedSamplingRate(component: string): number {\n  return AUTH_COMPONENTS.has(component) ? 1 : EVENT_SAMPLING_RATE;\n}\n\ntype ComponentMountedBase = {\n  component: string;\n};\n\ntype EventPrebuiltComponent = ComponentMountedBase & {\n  appearanceProp: boolean;\n  elements: boolean;\n  variables: boolean;\n  baseTheme: boolean;\n};\n\ntype EventComponentMounted = ComponentMountedBase & TelemetryEventRaw['payload'];\n\n/**\n * Factory for prebuilt component telemetry events.\n *\n * @internal\n */\nfunction createPrebuiltComponentEvent(event: typeof EVENT_COMPONENT_MOUNTED | typeof EVENT_COMPONENT_OPENED) {\n  return function (\n    component: string,\n    props?: Record<string, any>,\n    additionalPayload?: TelemetryEventRaw['payload'],\n  ): TelemetryEventRaw<EventPrebuiltComponent> {\n    return {\n      event,\n      eventSamplingRate:\n        event === EVENT_COMPONENT_MOUNTED ? getComponentMountedSamplingRate(component) : EVENT_SAMPLING_RATE,\n      payload: {\n        component,\n        appearanceProp: Boolean(props?.appearance),\n        baseTheme: Boolean(props?.appearance?.baseTheme),\n        elements: Boolean(props?.appearance?.elements),\n        variables: Boolean(props?.appearance?.variables),\n        ...additionalPayload,\n      },\n    };\n  };\n}\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for when a prebuilt (AIO) component is mounted.\n *\n * @param component - The name of the component.\n * @param props - The props passed to the component. Will be filtered to a known list of props.\n * @param additionalPayload - Additional data to send with the event.\n * @example\n * telemetry.record(eventPrebuiltComponentMounted('SignUp', props));\n */\nexport function eventPrebuiltComponentMounted(\n  component: string,\n  props?: Record<string, any>,\n  additionalPayload?: TelemetryEventRaw['payload'],\n): TelemetryEventRaw<EventPrebuiltComponent> {\n  return createPrebuiltComponentEvent(EVENT_COMPONENT_MOUNTED)(component, props, additionalPayload);\n}\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for when a prebuilt (AIO) component is opened as a modal.\n *\n * @param component - The name of the component.\n * @param props - The props passed to the component. Will be filtered to a known list of props.\n * @param additionalPayload - Additional data to send with the event.\n * @example\n * telemetry.record(eventPrebuiltComponentOpened('GoogleOneTap', props));\n */\nexport function eventPrebuiltComponentOpened(\n  component: string,\n  props?: Record<string, any>,\n  additionalPayload?: TelemetryEventRaw['payload'],\n): TelemetryEventRaw<EventPrebuiltComponent> {\n  return createPrebuiltComponentEvent(EVENT_COMPONENT_OPENED)(component, props, additionalPayload);\n}\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for when a component is mounted. Use `eventPrebuiltComponentMounted` for prebuilt components.\n *\n * **Caution:** Filter the `props` you pass to this function to avoid sending too much data.\n *\n * @param component - The name of the component.\n * @param props - The props passed to the component. Ideally you only pass a handful of props here.\n * @example\n * telemetry.record(eventComponentMounted('SignUp', props));\n */\nexport function eventComponentMounted(\n  component: string,\n  props: TelemetryEventRaw['payload'] = {},\n): TelemetryEventRaw<EventComponentMounted> {\n  return {\n    event: EVENT_COMPONENT_MOUNTED,\n    eventSamplingRate: getComponentMountedSamplingRate(component),\n    payload: {\n      component,\n      ...props,\n    },\n  };\n}\n","import type { TelemetryEventRaw } from '../../types';\n\nconst EVENT_METHOD_CALLED = 'METHOD_CALLED';\nconst EVENT_SAMPLING_RATE = 0.1;\n\ntype EventMethodCalled = {\n  method: string;\n} & Record<string, string | number | boolean>;\n\n/**\n * Fired when a helper method is called from a Clerk SDK.\n */\nexport function eventMethodCalled(\n  method: string,\n  payload?: Record<string, unknown>,\n): TelemetryEventRaw<EventMethodCalled> {\n  return {\n    event: EVENT_METHOD_CALLED,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload: {\n      method,\n      ...payload,\n    },\n  };\n}\n","import type { TelemetryEventRaw } from '../../types';\n\nconst EVENT_FRAMEWORK_METADATA = 'FRAMEWORK_METADATA';\nconst EVENT_SAMPLING_RATE = 0.1;\n\ntype EventFrameworkMetadata = Record<string, string | number | boolean>;\n\n/**\n * Fired when a helper method is called from a Clerk SDK.\n */\nexport function eventFrameworkMetadata(payload: EventFrameworkMetadata): TelemetryEventRaw<EventFrameworkMetadata> {\n  return {\n    event: EVENT_FRAMEWORK_METADATA,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload,\n  };\n}\n","import type { Appearance, BaseTheme, TelemetryEventRaw } from '../../types';\n\nexport const EVENT_THEME_USAGE = 'THEME_USAGE';\nexport const EVENT_SAMPLING_RATE = 1;\n\ntype EventThemeUsage = {\n  /**\n   * The name of the theme being used (e.g., \"shadcn\", \"neobrutalism\", etc.).\n   */\n  themeName?: string;\n};\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for tracking theme usage in ClerkProvider.\n *\n * @param appearance - The appearance prop from ClerkProvider.\n * @example\n * telemetry.record(eventThemeUsage(appearance));\n */\nexport function eventThemeUsage(appearance?: Appearance): TelemetryEventRaw<EventThemeUsage> {\n  const payload = analyzeThemeUsage(appearance);\n\n  return {\n    event: EVENT_THEME_USAGE,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload,\n  };\n}\n\n/**\n * Analyzes the appearance prop to extract theme usage information for telemetry.\n *\n * @internal\n */\nfunction analyzeThemeUsage(appearance?: Appearance): EventThemeUsage {\n  if (!appearance || typeof appearance !== 'object') {\n    return {};\n  }\n\n  // Prioritize the new theme property over deprecated baseTheme\n  const themeProperty = appearance.theme || appearance.baseTheme;\n\n  if (!themeProperty) {\n    return {};\n  }\n\n  let themeName: string | undefined;\n\n  if (Array.isArray(themeProperty)) {\n    // Look for the first identifiable theme name in the array\n    for (const theme of themeProperty) {\n      const name = extractThemeName(theme);\n      if (name) {\n        themeName = name;\n        break;\n      }\n    }\n  } else {\n    themeName = extractThemeName(themeProperty);\n  }\n\n  return { themeName };\n}\n\n/**\n * Extracts the theme name from a theme object.\n *\n * @internal\n */\nfunction extractThemeName(theme: BaseTheme): string | undefined {\n  if (typeof theme === 'string') {\n    return theme;\n  }\n\n  if (typeof theme === 'object' && theme !== null) {\n    // Check for explicit theme name\n    if ('name' in theme && typeof theme.name === 'string') {\n      return theme.name;\n    }\n  }\n\n  return undefined;\n}\n"],"mappings":"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"}